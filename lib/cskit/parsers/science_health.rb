# Autogenerated from a Treetop grammar. Edits may be lost.


# encoding: UTF-8

require 'pry'
require 'pry-nav'

module CSKit
  module Parsers

    module ScienceHealth
      include Treetop::Runtime

      def root
        @root ||= :citation
      end

      module Citation0
        def page
          elements[0]
        end

        def lines
          elements[2]
        end
      end

      module Citation1
        def content
          [page.content, lines.content]
        end
      end

      def _nt_citation
        start_index = index
        if node_cache[:citation].has_key?(index)
          cached = node_cache[:citation][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_page
        s0 << r1
        if r1
          if has_terminal?(":", false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(":")
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_lines
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Citation0)
          r0.extend(Citation1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:citation][start_index] = r0

        r0
      end

      module Page0
        def content
          [:page, text_value]
        end
      end

      def _nt_page
        start_index = index
        if node_cache[:page].has_key?(index)
          cached = node_cache[:page][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[\\d{1,3}|vi{2}|xi{1,2}|i{0,1}x]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(Page0)
        end

        node_cache[:page][start_index] = r0

        r0
      end

      module Lines0
        def content
          [:lines, elements.map { |e| e.content if e.respond_to?(:content) }]
        end
      end

      def _nt_lines
        start_index = index
        if node_cache[:lines].has_key?(index)
          cached = node_cache[:lines][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?('\G[(multi_line / line_number) ","?]', true, index)
            r1 = true
            @index += 1
          else
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Lines0)

        node_cache[:lines][start_index] = r0

        r0
      end

      module MultiLine0
        def line_number1
          elements[0]
        end

        def line_number2
          elements[2]
        end
      end

      module MultiLine1
        def content
          start, finish = case elements.size
            when 1 then [elements[0], nil]
            when 3 then [elements[0].content, elements[2].content]
            else
              raise "Illegal line numbers found."
          end

          [[:start, start], [:finish, finish]]
        end
      end

      def _nt_multi_line
        start_index = index
        if node_cache[:multi_line].has_key?(index)
          cached = node_cache[:multi_line][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_line_number
        s0 << r1
        if r1
          if has_terminal?("-", false, index)
            r2 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("-")
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_line_number
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(MultiLine0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:multi_line][start_index] = r0

        r0
      end

      module LineNumber0
        def content
          text_value.to_i
        end
      end

      def _nt_line_number
        start_index = index
        if node_cache[:line_number].has_key?(index)
          cached = node_cache[:line_number][index]
          if cached
            cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?('\G[\\d{1,2}]', true, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          r0.extend(LineNumber0)
          @index += 1
        else
          r0 = nil
        end

        node_cache[:line_number][start_index] = r0

        r0
      end

    end

    class ScienceHealthParser < Treetop::Runtime::CompiledParser
      include ScienceHealth
    end


  end
end
